<!DOCTYPE html>
<html><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Javascript: The Bad Parts | fiddlybits</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Javascript: The Bad Parts" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Last week I stumbled upon TC39’s record and tuple proposal for the first time, and was really happy to see the language taking a long-overdue big step forward in safety and usability." />
<meta property="og:description" content="Last week I stumbled upon TC39’s record and tuple proposal for the first time, and was really happy to see the language taking a long-overdue big step forward in safety and usability." />
<link rel="canonical" href="https://blog.sea.nkelley.me/2021/02/03/javascript-the-bad-parts/" />
<meta property="og:url" content="https://blog.sea.nkelley.me/2021/02/03/javascript-the-bad-parts/" />
<meta property="og:site_name" content="fiddlybits" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-02-03T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Javascript: The Bad Parts" />
<script type="application/ld+json">
{"dateModified":"2021-02-03T00:00:00+00:00","datePublished":"2021-02-03T00:00:00+00:00","headline":"Javascript: The Bad Parts","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.sea.nkelley.me/2021/02/03/javascript-the-bad-parts/"},"url":"https://blog.sea.nkelley.me/2021/02/03/javascript-the-bad-parts/","@type":"BlogPosting","description":"Last week I stumbled upon TC39’s record and tuple proposal for the first time, and was really happy to see the language taking a long-overdue big step forward in safety and usability.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/style.css">
  <link type="application/atom+xml" rel="alternate" href="https://blog.sea.nkelley.me/feed.xml" title="fiddlybits" /></head>
<body data-theme="auto"><header class="site-header">
  <div class="centering-wrapper">
    <a class="site-title" href="/">fiddlybits</a>
    <span>
      <a href="https://github.com/seansfkelley">github</a>
      &nbsp;•&nbsp;
      <a href="/feed.xml">rss</a>
      <!-- Only show theme switcher if js is enabled: hide by default. -->
      <span id="theme-switcher-wrapper" style="display: none;">
        &nbsp;•&nbsp;
        <a href="#" id="theme-switcher"></a>
      </span>
    </span>
  </div>
</header>
<main class="centering-wrapper">
      <article class="post">
  <header class="post-header">
    <h1 class="post-title">Javascript: The Bad Parts</h1>
    <h3 class="post-subtitle"></h3>
  </header><p>Last week I stumbled upon TC39’s <a href="https://github.com/tc39/proposal-record-tuple">record and tuple proposal</a> for the first time, and was really happy to see the language taking a long-overdue big step forward in safety and usability.</p>

<p>It also prompted me to write this post so that I don’t have to repeat myself to those unfortunate souls who have to hear me rail against the language.</p>

<h2 class="no_toc" id="table-of-complaints">Table of Complaints</h2>

<ul id="markdown-toc">
  <li><a href="#automatic-type-coercion" id="markdown-toc-automatic-type-coercion">Automatic Type Coercion</a></li>
  <li><a href="#two-null-types-null-and-undefined" id="markdown-toc-two-null-types-null-and-undefined">Two Null Types: <code class="language-plaintext highlighter-rouge">null</code> and <code class="language-plaintext highlighter-rouge">undefined</code></a></li>
  <li><a href="#dynamic-this" id="markdown-toc-dynamic-this">Dynamic <code class="language-plaintext highlighter-rouge">this</code></a></li>
  <li><a href="#conflation-of-record-and-map-types" id="markdown-toc-conflation-of-record-and-map-types">Conflation of “Record” and “Map” Types</a></li>
  <li><a href="#reference-semantics-and-the-failures-of-map-and-set" id="markdown-toc-reference-semantics-and-the-failures-of-map-and-set">Reference Semantics and the Failures of <code class="language-plaintext highlighter-rouge">Map</code> and <code class="language-plaintext highlighter-rouge">Set</code></a></li>
  <li><a href="#things-people-complain-about-that-i-dont-think-matter" id="markdown-toc-things-people-complain-about-that-i-dont-think-matter">Things People Complain About That I Don’t Think Matter</a>    <ul>
      <li><a href="#prototypal-inheritance" id="markdown-toc-prototypal-inheritance">Prototypal Inheritance</a></li>
      <li><a href="#dynamic-nature-of-closure-references" id="markdown-toc-dynamic-nature-of-closure-references">Dynamic Nature of Closure References</a></li>
      <li><a href="#only-floating-point-numbers" id="markdown-toc-only-floating-point-numbers">Only Floating-Point Numbers</a></li>
      <li><a href="#optional-semicolons" id="markdown-toc-optional-semicolons">Optional Semicolons</a></li>
      <li><a href="#for-of-versus-for-in" id="markdown-toc-for-of-versus-for-in"><code class="language-plaintext highlighter-rouge">for-of</code> versus <code class="language-plaintext highlighter-rouge">for-in</code></a></li>
    </ul>
  </li>
  <li><a href="#lightning-round-things-that-dont-matter-anymore" id="markdown-toc-lightning-round-things-that-dont-matter-anymore">Lightning Round: Things That Don’t Matter Anymore</a></li>
  <li><a href="#what-about-records-and-tuples" id="markdown-toc-what-about-records-and-tuples">What About Records and Tuples?</a></li>
</ul>

<h2 id="automatic-type-coercion">Automatic Type Coercion</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="dl">""</span><span class="p">);</span>
<span class="nf">assert</span><span class="p">([]</span> <span class="o">==</span> <span class="dl">""</span><span class="p">);</span>
<span class="nf">assert</span><span class="p">({}</span> <span class="o">!=</span> <span class="dl">""</span><span class="p">);</span>
</code></pre></div></div>

<p>(FYI: This page has a basic <code class="language-plaintext highlighter-rouge">assert</code> function defined if you want to pop open the browser console and copy-paste these examples in.)</p>

<p>Maybe in the early days of the web when everyone was flying by the seat of their pants it made sense to paper over newbie mistakes like comparing a stringified number to a number literal.</p>

<p>That said, automatic type coercion is a feature very rarely seen in other programming languages to this degree. Even Python, which lets you overload almost every conceivable hook, tends to avoid this type of behavior. The cases it does appear in are usually highly restricted, such as allowing comparison between a datetime and a string, or a datetime and a number.</p>

<p>I can’t think of a single case where it is desirable, from a correctness, readability and maintainability perspective, to allow comparing numbers to strings and come up with a “sane” result. <a href="https://eslint.org/docs/rules/eqeqeq">ESLint recommends against it as “good practice”</a>. This type of behavior should be opt-in, or at least highly restricted by default.</p>

<h2 id="two-null-types-null-and-undefined">Two Null Types: <code class="language-plaintext highlighter-rouge">null</code> and <code class="language-plaintext highlighter-rouge">undefined</code></h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">assert</span><span class="p">(({}).</span><span class="nx">foo</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">);</span>
<span class="nf">assert</span><span class="p">(</span><span class="dl">"</span><span class="s2">bar</span><span class="dl">"</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="sr">/foo/</span><span class="p">)</span> <span class="o">===</span> <span class="kc">null</span><span class="p">);</span>
<span class="nf">assert</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nf">stringify</span><span class="p">({</span> <span class="na">foo</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span> <span class="na">bar</span><span class="p">:</span> <span class="kc">undefined</span> <span class="p">})</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">{"foo":null}</span><span class="dl">'</span><span class="p">);</span>
<span class="nf">assert</span><span class="p">(</span><span class="k">typeof</span> <span class="kc">null</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">object</span><span class="dl">"</span><span class="p">);</span>
<span class="nf">assert</span><span class="p">(</span><span class="k">typeof</span> <span class="kc">undefined</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">undefined</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<p>JavaScript kind of worked itself into a corner on this one, because it wanted to silently report a null value for fields that didn’t exist on objects. Unlike <code class="language-plaintext highlighter-rouge">==</code>, I can kind of see the value in this feature both during the flying-by-the-seat-of-your-pants phase and after. Objective-C, for instance, has well-defined semantics for sending messages to nil (or “calling methods on null” in more-normal terminology).<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<p>When supporting silently returning null from a nonexistent field, how would one differentiate between “object does not have this field” and “object has this field, but it’s null”? Do you even need to? This is actually a very tricky question which most languages sidestep by not having this feature at all – it is an error to access an unknown field, even in languages where you can define fields dynamically through introspection.</p>

<p>JavaScript’s approach is to instead dump this tricky question onto the end user, again and again and again. Some standard library methods return <code class="language-plaintext highlighter-rouge">null</code> in failure or no-op cases, some <code class="language-plaintext highlighter-rouge">undefined</code>. Some accept only one of them as the “do nothing” input and throw errors on the other. JSON serialization treats them differently. You can assign an object field to <code class="language-plaintext highlighter-rouge">undefined</code>, which makes it truly weird to understand if the field in question exists (but is undefined) or doesn’t exist at all. They respond differently to <code class="language-plaintext highlighter-rouge">typeof</code> and <code class="language-plaintext highlighter-rouge">===</code>. Every corner of the language becomes a trap, even more so than the <a href="https://en.wikipedia.org/wiki/Null_pointer#History">billion-dollar mistake</a> that it already was.<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></p>

<p>Thankfully, and with immense irony, <code class="language-plaintext highlighter-rouge">==</code> can be used to mostly ignore the differences when doing the most common operation with null values, checking if they are null, since coercion treats them both the same.</p>

<h2 id="dynamic-this">Dynamic <code class="language-plaintext highlighter-rouge">this</code></h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Foo</span> <span class="p">{</span> <span class="nf">getThis</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">;</span> <span class="p">}};</span>
<span class="kd">const</span> <span class="nx">fn</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Foo</span><span class="p">().</span><span class="nx">getThis</span><span class="p">;</span>
<span class="nf">assert</span><span class="p">(</span><span class="nf">fn</span><span class="p">()</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">);</span>
</code></pre></div></div>

<p>Dynamic <code class="language-plaintext highlighter-rouge">this</code> is an interesting feature in theory, but in practice the implementation and usage is confusing if not outright developer-hostile. In every language with it, <code class="language-plaintext highlighter-rouge">this</code> is just syntactic sugar to name an implicit argument to an instance method. Dynamic <code class="language-plaintext highlighter-rouge">this</code> is just giving you a mechanism to provide a value for that parameter, which sounds simple on paper.</p>

<p>The problem is that it’s half-baked: you have to step carefully when passing around a function reference from an object lest you end up with <code class="language-plaintext highlighter-rouge">this === window</code> or <code class="language-plaintext highlighter-rouge">this === undefined</code>, both of which are certainly undesirable when dealing with those function references. But the implicit-by-definition nature of the <code class="language-plaintext highlighter-rouge">this</code> keyword strongly evokes C-family-style non-dynamic (…static?) <code class="language-plaintext highlighter-rouge">this</code>, which is incorrect.</p>

<p>The closest fully-baked comparison I can think of is Python. Python offers the same semantics in the end, but differs in two crucial ways:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">self</code> is an explicitly declared parameter, avoiding the need for a keyword and serving as a reminder to the developer that it isn’t (that) special</li>
  <li>you can only provide the value for <code class="language-plaintext highlighter-rouge">self</code> by invoking the method statically,<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup> which takes a bit of extra typing</li>
</ul>

<p>It’s effectively impossible in Python to end up with the “wrong” <code class="language-plaintext highlighter-rouge">self</code> in the course of normal development, even when you’re doing some light metaprogramming.</p>

<p>JavaScript’s dynamic <code class="language-plaintext highlighter-rouge">this</code> is nothing more than a trap that ends up netting zero keystrokes saved – think of all the usages of <code class="language-plaintext highlighter-rouge">bind</code> or fat arrows one needs to sprinkle around to compensate – while adding cognitive overhead unique among common programming languages.</p>

<h2 id="conflation-of-record-and-map-types">Conflation of “Record” and “Map” Types</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">map</span><span class="p">[{</span> <span class="na">my</span><span class="p">:</span> <span class="dl">"</span><span class="s2">object</span><span class="dl">"</span> <span class="p">}]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="nf">assert</span><span class="p">(</span><span class="nx">map</span><span class="p">[</span><span class="dl">'</span><span class="s1">[object Object]</span><span class="dl">'</span><span class="p">]</span> <span class="o">===</span> <span class="mi">10</span><span class="p">);</span>
</code></pre></div></div>

<p>First, some definitions. A “record” type is one which has a well-known set of field names that can be accessed to retreive values. A “map” is a data structure that pairs up arbitrary keys with arbitrary values. A record can be thought of as a special case of a map that only allows string keys.</p>

<p>Until the introduction of ES6 <code class="language-plaintext highlighter-rouge">Map</code>, JavaScript had no real map type at all. I have personally written and witnessed some pretty absurd workarounds for this shortcoming, up to and including serializing objects as map keys into JSON, which is both tedious and of questionable correctness (what if your serialization changes key ordering?).</p>

<p>Before <code class="language-plaintext highlighter-rouge">Map</code>, JavaScript had no way to performantly <em>and</em> correctly implement the basic map type that comes with all standard libraries. What one would expect to do when coming from other languages – that is, to provide the object directly as the key – would silently “succeed” with the utterly useless and dreaded <code class="language-plaintext highlighter-rouge">[object Object]</code> stringification.</p>

<p>Non-standard-library map implementations have to use expensive object serialization or tree structures in order to maintain correctness without sacrificing too much performance, and do not have the slick syntactic support that objects-as-maps did. Given that most usages of maps either use primitives (say, object IDs or string enumerations) or can be relatively easily rewritten as such with just a little extra field access, this is a problem less often than when you would think. But when it’s a problem – say, you want to use tuple keys – it’s a showstopper.</p>

<h2 id="reference-semantics-and-the-failures-of-map-and-set">Reference Semantics and the Failures of <code class="language-plaintext highlighter-rouge">Map</code> and <code class="language-plaintext highlighter-rouge">Set</code></h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">assert</span><span class="p">(</span><span class="k">new</span> <span class="nc">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]).</span><span class="nx">size</span> <span class="o">===</span> <span class="mi">1</span><span class="p">);</span>
<span class="nf">assert</span><span class="p">(</span><span class="k">new</span> <span class="nc">Set</span><span class="p">([{},</span> <span class="p">{}]).</span><span class="nx">size</span> <span class="o">===</span> <span class="mi">2</span><span class="p">);</span>
</code></pre></div></div>

<p>Continuing from the previous section: <code class="language-plaintext highlighter-rouge">Map</code> didn’t really fix many problems, practically speaking. Yes, JavaScript now had a dedicated map type, so objects-as-maps were theoretically obsolete. But  <code class="language-plaintext highlighter-rouge">Map</code> (and <code class="language-plaintext highlighter-rouge">Set</code>, which has all the same problems) operates using reference equality, not value equality.</p>

<p>The choice to use reference equality instead of value equality makes a lot of sense in context: JavaScript has a weak-to-nonexistent notion of value equality (or, more generally, comparisons by value). The only values for which value and reference equality are the same are primitives, so in the case where you were using objects as maps whose values were strings, numbers (coerced to strings) or booleans (coerced to strings), you may see an improvement in type sanity.</p>

<p>However, the use of reference equality mean that <code class="language-plaintext highlighter-rouge">Map</code> and <code class="language-plaintext highlighter-rouge">Set</code> wildly underdeliver on their promise to provide a sane alternative to JSON serializing objects to use them as map keys, because if you aren’t extremely careful about maintaining reference equality in the rest of your code, you will run into all manner of correctness issues: keys missing that you thought would be there, keys present that you thought you had deleted, duplicates with identical values…</p>

<p>As a kicker, many idiomatic usages of JavaScript encourage using spreading and destructuring (among other things) to ensure that objects are immutable over their lifetime. This has a lot of correctness and debuggability benefits, but means these objects are effectively impossible to use with <code class="language-plaintext highlighter-rouge">Map</code> and <code class="language-plaintext highlighter-rouge">Set</code>. A series of immutable updates to an object could yield any number of value-equals but reference-different immutable objects that won’t behave as intended if you use them with <code class="language-plaintext highlighter-rouge">Map</code> or <code class="language-plaintext highlighter-rouge">Set</code>. Correctness checks or performance optimizations that would be obvious and free in other languages – such as checking for cache hits with an object key – are difficult to implement.</p>

<h2 id="things-people-complain-about-that-i-dont-think-matter">Things People Complain About That I Don’t Think Matter</h2>

<p>While I’m complaining, let me complain about other peoples’ complaints too.</p>

<h3 id="prototypal-inheritance">Prototypal Inheritance</h3>

<p>I can’t recall ever seeing any significant usage of prototypal inheritance that isn’t exactly equivalent to a class hierarchy in other languages. Yes, you can reassign <code class="language-plaintext highlighter-rouge">__proto__</code>, and yes, non-class things can have prototypes that make them behave sort of like subclasses. I’ve seen the occasional usage of these patterns, but in every single case they have boiled down to an unusual and roundabout way of saying <code class="language-plaintext highlighter-rouge">extends</code>. With the addition of the <code class="language-plaintext highlighter-rouge">class</code> keyword (implemented with prototypal inheritance, of course), I think prototypal inheritance is basically irrelevant.</p>

<h3 id="dynamic-nature-of-closure-references">Dynamic Nature of Closure References</h3>

<p>A motivating code sample:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">fns</span> <span class="o">=</span> <span class="p">[];</span>
<span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">fns</span><span class="p">.</span><span class="nf">push</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">fns</span><span class="p">.</span><span class="nf">forEach</span><span class="p">(</span><span class="nx">fn</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nf">fn</span><span class="p">());</span> <span class="p">});</span>
<span class="c1">// prints "3" three times</span>
</code></pre></div></div>

<p>(Note: this works “as expected” if you declare <code class="language-plaintext highlighter-rouge">let i</code> instead.)</p>

<p>I think this is fine. Some languages capture closed-over values by direct reference and some capture the whole environment and evaluate the reference later. They’re better for different things, and you can always express patterns that are easier in one in some fashion in the other. You just have to learn which way your language functions.</p>

<h3 id="only-floating-point-numbers">Only Floating-Point Numbers</h3>

<p>The vast majority of production code uses small integers and small floating-point numbers. It’s somewhat frustrating that JavaScript uses an unusual standard that allows neither full (32- or 64-bit) integers or floats, but a hybrid shorter form of both. But if these lower-than-normal limits or lack of integer/float separation matter to you, you should probably be using a different representation anyway, such as <code class="language-plaintext highlighter-rouge">BigInt</code> for currencies or strings for 64-bit database IDs.</p>

<h3 id="optional-semicolons">Optional Semicolons</h3>

<p>I cannot fathom why the language designers bothered with this feature. Either make the language require seimcolons or not. Why is this a choice that developers have to make? Unlike <code class="language-plaintext highlighter-rouge">'</code> versus <code class="language-plaintext highlighter-rouge">"</code> (which allow nesting) or <code class="language-plaintext highlighter-rouge">var</code> versus <code class="language-plaintext highlighter-rouge">let</code> (which have different semantics), there is literally zero value to optional semicolons. It’s pure flamebait, but <a href="https://prettier.io/docs/en/options.html#semicolons">Prettier picked a side</a> so you don’t have to.</p>

<h3 id="for-of-versus-for-in"><code class="language-plaintext highlighter-rouge">for-of</code> versus <code class="language-plaintext highlighter-rouge">for-in</code></h3>

<p>While I think that the semantics of <code class="language-plaintext highlighter-rouge">for-in</code> are downright silly – an array’s indices are far less interesting than the value and probably don’t need their own syntactic sugar – the advice here seems pretty clear: always use <code class="language-plaintext highlighter-rouge">for-of</code>. I would go even further and say: you almost always want to use <code class="language-plaintext highlighter-rouge">forEach</code>, or <code class="language-plaintext highlighter-rouge">map</code>, or <code class="language-plaintext highlighter-rouge">reduce</code>, etc. Chances are you’re doing an operation that is better suited to one or more higher-order functions anyway. I think in the last three years of writing TypeScript I’ve only written a single <code class="language-plaintext highlighter-rouge">for</code> loop, and that was because it needed very particular early-abort semantics.</p>

<h2 id="lightning-round-things-that-dont-matter-anymore">Lightning Round: Things That Don’t Matter Anymore</h2>

<p>I am relieved that these have become effective non-issues.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">with</code>: terrible idea, glad it was dead on arrival.</li>
  <li><code class="language-plaintext highlighter-rouge">eval</code>: fun while it lasted, but always a bad idea.</li>
  <li><code class="language-plaintext highlighter-rouge">var</code>: block-scoped declarations are the right choice.</li>
  <li><code class="language-plaintext highlighter-rouge">new Boolean()</code> versus <code class="language-plaintext highlighter-rouge">Boolean</code> (etc.): technically still an issue, but new standard library types are taking a stance to avoid more confusion.</li>
</ul>

<h2 id="what-about-records-and-tuples">What About Records and Tuples?</h2>

<p>The <a href="https://github.com/tc39/proposal-record-tuple">record and tuple proposal</a> that introduced this post is interesting to me because it solves, or contributes to a solution for, the worst of the above problems.</p>

<p>With language-level immutability, I can spend less mental energy on careful use of spread and destructuring, and can use <code class="language-plaintext highlighter-rouge">Map</code> and <code class="language-plaintext highlighter-rouge">Set</code> for what they’re meant for – basic collection types respecting value equality. I can also almost entirely stop using objects, since I generally either want a <code class="language-plaintext highlighter-rouge">Map</code> or a <code class="language-plaintext highlighter-rouge">Record</code>, and not some weird hybrid.</p>

<p>Arrays continue be useful, but they’ve always been less weird than objects, so it’s okay.</p>

<p>As for <code class="language-plaintext highlighter-rouge">===</code> and dynamic <code class="language-plaintext highlighter-rouge">this</code>, well, I have linters and more brainspace to dedicate now that I’m not thinking about the pitfalls of objects all the time.</p>

<hr />

<section class="next-previous">
  
  <a href="/2021/01/09/passprompt/" class="next-previous-link next-previous-left" title="Previous Post: passprompt: Nag Yourself to Remember Your Passwords">
    <span class="next-previous-icon">←</span>
    <div class="next-previous-name">
      <div class="next-previous-label">Previous Post</div>
      <div class="next-previous-title">passprompt: Nag Yourself to Remember Your Passwords</div>
    </div>
  </a>
  
  
  <a href="/2021/04/12/wiping-drives-with-dd/" class="next-previous-link next-previous-right" title="Next Post: Wiping Corrupt Drives with dd: The Nuclear Option">
    <div class="next-previous-name">
      <div class="next-previous-label">Next Post</div>
      <div class="next-previous-title">Wiping Corrupt Drives with dd: The Nuclear Option</div>
    </div>
    <span class="next-previous-icon">→</span>
  </a>
  
</section>
<hr />

<script type="text/javascript">
  function assert(c) {
    if (!c) {
      throw new Error("assertion failure");
    }
  }
</script>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Objective-C is an extensively flawed and weird language in its own right, but let’s not get into that here. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>Inflation and the pervasiveness of software mean that this cost is definitely <em>well</em> above a billion at this point. But I don’t fault C.A.R. Hoare, the null reference was inevitable and entirely reasonable. Optional types are big in imperative languages now, anyway. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>It’s entirely possible there are other incantations that allow configuring <code class="language-plaintext highlighter-rouge">self</code> that I don’t know about. But the point stands: Python does the sane thing by default when using method references, and requires extra effort to do weird stuff. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
<footer>
    <p class="post-date">
      ~
      <time
        datetime="2021-02-03T00:00:00+00:00"
        itemprop="datePublished"
      >
        2021-02-03
      </time>~
    </p>
  </footer>
</article>

      <!--
        This filthy trick makes sure that the content always weakly tries to expand to the full
        width available, but allows for linebreaks if the viewport is too small. It produces a
        better result than, say, width: 100%; or width: some-fixed-pixel-amount; and doesn't require
        rewriting everything to flexbox (which would mess with the <html>-level scroll behavior and
        sticky header) or adding extra DOM (which I'm trying to minimize to make myself feel good).
      -->
      <div class="horizontal-expander" aria-hidden="true">
        Throughout human history, we have been dependent on machines to survive. Fate, it seems, is not without a sense of irony.
      </div>
    </main>
  </body>
  <script src="/assets/js/theme-switcher.js"></script>
  
</html>
