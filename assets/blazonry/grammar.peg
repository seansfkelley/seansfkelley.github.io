// Note: nothing is case insensitive here because it is assumed to only parse lowercase input.

Enter
  = content:ComplexContent _ "."? { return content }

ComplexContent
  = SimpleField
  / PartyPerField
  / Quarterly

SimpleField
  = tincture:Tincture _ content:SimpleContent? { return { tincture, content } }
  / varied:Varied _ first:Tincture _ "and" _ second:Tincture _ content:SimpleContent? { return { varied, first, second, content } }

PartyPerField
  = Party? _ "per" _ party:Direction _ ornament:Ornament? _ first:Tincture _ "and" _ second:Tincture _ content:SimpleContent? { return { party, first, second, content, ornament } }

Party
  = "party"
  / "parted"

Quarterly
  = "quarterly" _ quarters:Quarter+ { return { quarters } }

SimpleContent
  // Order matters here since multiple rules in this block start with an Ordinary.
  = on:Ordinary _ "between" _ surround:Charge { return { on, surround } }
  / "on" _ on:Ordinary _ charge:Charge { return { on, charge } }
  / "on" _ on:Ordinary _ "between" _ surround:Charge _ charge:Charge { return { on, surround, charge } }
  / Ordinary
  / Charge
  / Canton

Quarter "quartering"
  // TODO: Make this an actual list rule?
  = quarter:QuarterName _ content:ComplexContent { return { quarters: [quarter], content } }
  / quarter1:QuarterName _ "and" _ quarter2:QuarterName _ content:ComplexContent { return { quarters: [quarter1, quarter2], content  } }
  / quarter1:QuarterName _ quarter2:QuarterName _ "and" _ quarter3:QuarterName _ content:ComplexContent { return { quarters: [quarter1, quarter2, quarter3], content  } }
  / quarter1:QuarterName _ quarter2:QuarterName _ quarter3:QuarterName _ "and" _ quarter4:QuarterName _ content:ComplexContent { return { quarters: [quarter1, quarter2, quarter3, quarter4], content  } }

Canton "canton"
  = "a" _ "canton" _ tincture:Tincture { return { canton: tincture } }
  / "on" _ "a" _ "canton" _ tincture:Tincture _ content:SimpleContent { return { canton: tincture, content } }

Ordinary "ordinary"
  // Note that we do not support multiple ordinaries. Yet?
  = Singular _ ordinary:OrdinaryName _ ornament:Ornament? _ tincture1:Tincture? _ "cotised" _ tincture2:Tincture { return { ordinary, tincture: tincture1 ?? tincture2, cotised: tincture2, ornament } }
  / Singular _ ordinary:OrdinaryName _ ornament:Ornament? _ tincture:Tincture { return { ordinary, tincture, ornament } }

Charge "charge"
  = Singular _ charge:SimpleChargeName _ posture:Posture? _ tincture:Tincture { return { charge, tincture, posture, count: 1 } }
  / count:Plural _ charge:SimpleChargeName "s" _ posture:Posture? _ tincture:Tincture _ direction:InDirection? { return { charge, tincture, posture, count, direction } }
  / Lion

Lion
  = "a" _ "lion" _ description:LionDescription { return { ...description, count: 1 } }
  / count:Plural _ "lions" _ description:LionDescription { return { ...description, count } }

// This extra layer of indirection is pretty meh. It's here because we want to couple this verbiage
// to the presence of the "lion" charge "keyword", above, combined with the requirement that the
// pluralization is in the middle of the spec, rather than at the end ("s") like a simple charge.
LionDescription
  = pose:LionPose? _ posture:Posture? _ tincture:Tincture _ modifiers:LionModifiers? _ direction:InDirection? { return { charge: "lion", tincture, posture, pose: pose ?? "rampant",  ...modifiers, direction } }

LionPose
  = "rampant"
  / "passant"
  // other variants: "passant guardant", "reguardant"

LionModifier
  = "armed"
  / "langued"
  // other variants: "crowned", "double queued"

LionModifiers
  // This is unfortunately rather repetitive, due to the optional nature of the tincture
  // specification when using both "armed" and "langued". Not sure how to tighten it up.
  = modifier1:LionModifier _ tincture1:Tincture _ "and" _ modifier2:LionModifier _ tincture2:Tincture { return { [modifier1]: tincture1, [modifier2]: tincture2 } }
  / modifier:LionModifier _ tincture:Tincture { return { [modifier]: tincture } }
  / modifier1:LionModifier _ "and" _ modifier2:LionModifier _ tincture:Tincture { return { [modifier1]: tincture, [modifier2]: tincture } }

Singular "a/an"
  = "a"
  / "an"

Plural "plural quantity"
  = "two" { return 2 }
  / "three" { return 3 }
  / "four" { return 4 }
  / "five" { return 5 }
  / "six" { return 6 }
  / "seven" { return 7 }
  / "eight" { return 8 }
  / "nine" { return 9 }
  / "ten" { return 10 }
  / "eleven" { return 11 }
  / "twelve" { return 12 }

Direction "direction"
  = "pale"
  / "fess"
  / "bend"
  / "chevron"
  / "saltire"

InDirection "direction"
  = "in" _ direction:Direction { return direction }
  // Special case: things can be "in cross" but they can't be "party per cross". (It is synonymous
  // with "quarterly" but we don't allow it because it's a pain to implement.)
  / "in" _ "cross" { return "cross" }

QuarterName "quarter name"
  = "first" { return 1 }
  / "1st" { return 1 }
  / "second" { return 2 }
  / "2nd" { return 2 }
  / "third" { return 3 }
  / "3rd" { return 3 }
  / "fourth" { return 4 }
  / "4th" { return 4 }

Posture "posture"
  = "palewise"
  / "fesswise"
  / "bendwise"
  / "saltirewise"

Tincture "tincture"
  = "azure"
  / "or"
  / "argent"
  / "gules"
  / "vert"
  / "sable"
  / "purpure"
  / "counterchanged"

OrdinaryName "ordinary name"
  = "bend"
  / "fess"
  / "cross"
  / "chevron"
  / "pale"
  / "saltire"
  / "chief"

SimpleChargeName "charge name"
  = "sword"
  / "rondel"
  / "mullet"

Varied "varied"
  = type:VariedName _ "of" _ count:Plural { return { type, count } }
  / type:VariedName { return { type } }

VariedName "varied name"
  = "barry bendy"
  / "barry"
  / "bendy"
  / "checky"
  / "chequey" { return "checky" }
  / "chevronny"
  / "lozengy"
  / "paly"

Ornament "ornament"
  = "embattled"
  / "engrailed"
  / "indented"
  // TODO: More.

_ "whitespace"
  // Note that comma and semicolon are considered, effectively, whitespace. It is not used to delimit anything that is not already delimited by whitespace.
  = [,; \t\n\r]*
